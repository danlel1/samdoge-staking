<!-- Dépendance ethers.js (v6) -->
<script src="https://cdn.jsdelivr.net/npm/ethers@6.13.1/dist/ethers.umd.min.js"></script>

<div id="widget" class="mt-8 rounded-2xl p-8 border border-white/15 bg-white/5">
  <h2 class="text-xl font-bold mb-4">Staking SamDoge (pré-widget)</h2>

  <div class="flex flex-wrap gap-3">
    <button id="connectBtn" class="btn">Connecter MetaMask</button>
    <button id="addTokenBtn" class="btn" style="background:#111">Ajouter SDM à MetaMask</button>
  </div>

  <div id="walletInfo" class="mt-5 hidden">
    <p><strong>Adresse:</strong> <span id="account" class="mono"></span></p>
    <p class="mt-1"><strong>Solde SDM:</strong> <span id="sdmBalance">—</span></p>
  </div>

  <hr class="my-6 border-white/20">

  <!-- Préparation staking (à activer quand tu auras le contrat de staking) -->
  <div class="grid md:grid-cols-2 gap-4">
    <div class="rounded-xl p-4 border border-white/15 bg-white/5">
      <div class="text-white/70 text-sm mb-2">Montant à staker (SDM)</div>
      <input id="amountInput" type="number" min="0" step="0.000001"
             class="w-full rounded-lg px-3 py-2 text-gray-900"
             placeholder="0.0">
      <button id="approveBtn" class="btn mt-3">Approve SDM</button>
      <button id="stakeBtn"   class="btn mt-3" disabled>Stake (bientôt)</button>
    </div>
    <div class="rounded-xl p-4 border border-white/15 bg-white/5">
      <div class="text-white/70 text-sm">Actions</div>
      <button id="unstakeBtn" class="btn mt-3" disabled>Unstake (bientôt)</button>
      <button id="claimBtn"   class="btn mt-3" disabled>Claim rewards (bientôt)</button>
    </div>
  </div>

  <p id="status" class="mt-4 text-white/80"></p>
</div>

<script>
  // === Paramètres projet ===
  const TOKEN_ADDRESS   = "0xca4bdeb1e713be6b50e3800e0cb0263852ebefd9"; // SDM
  const TOKEN_SYMBOL    = "SDM";
  const TOKEN_DECIMALS  = 18;
  const STAKING_ADDRESS = "0xYOUR_STAKING_CONTRACT_HERE"; // TODO: à remplacer

  // BSC mainnet chain params
  const BSC_PARAMS = {
    chainId: "0x38", // 56
    chainName: "BNB Smart Chain",
    nativeCurrency: { name: "BNB", symbol: "BNB", decimals: 18 },
    rpcUrls: ["https://bsc-dataseed.binance.org"],
    blockExplorerUrls: ["https://bscscan.com"]
  };

  // ABI minimal ERC-20 (balanceOf, allowance, approve)
  const ERC20_ABI = [
    "function balanceOf(address) view returns (uint256)",
    "function allowance(address owner, address spender) view returns (uint256)",
    "function approve(address spender, uint256 amount) returns (bool)"
  ];

  // Éléments UI
  const connectBtn = document.getElementById("connectBtn");
  const addTokenBtn = document.getElementById("addTokenBtn");
  const walletInfo = document.getElementById("walletInfo");
  const accountEl  = document.getElementById("account");
  const sdmBalEl   = document.getElementById("sdmBalance");
  const amountIn   = document.getElementById("amountInput");
  const approveBtn = document.getElementById("approveBtn");
  const stakeBtn   = document.getElementById("stakeBtn");
  const statusEl   = document.getElementById("status");

  let provider, signer, userAddress, token;

  function setStatus(msg){ statusEl.textContent = msg || ""; }

  async function ensureBSC(){
    const chainId = await window.ethereum.request({ method: "eth_chainId" });
    if (chainId !== BSC_PARAMS.chainId){
      try {
        await window.ethereum.request({ method: "wallet_switchEthereumChain", params: [{ chainId: BSC_PARAMS.chainId }] });
      } catch (e){
        if (e.code === 4902){
          await window.ethereum.request({ method: "wallet_addEthereumChain", params: [BSC_PARAMS] });
        } else { throw e; }
      }
    }
  }

  async function connect(){
    if (!window.ethereum){ alert("Installe MetaMask pour continuer."); return; }
    try{
      // Demande connexion
      const accounts = await window.ethereum.request({ method:"eth_requestAccounts" });
      userAddress = accounts[0];

      // Bascule/ajout BSC si besoin
      await ensureBSC();

      // Ethers v6
      provider = new ethers.BrowserProvider(window.ethereum);
      signer   = await provider.getSigner();
      token    = new ethers.Contract(TOKEN_ADDRESS, ERC20_ABI, signer);

      accountEl.textContent = userAddress;
      walletInfo.classList.remove("hidden");
      setStatus("Wallet connecté. Lecture du solde SDM…");

      await refreshBalances();

      // écoutes changement de compte / réseau
      window.ethereum.on?.("accountsChanged", ()=> location.reload());
      window.ethereum.on?.("chainChanged",    ()=> location.reload());

    }catch(err){
      console.error(err);
      alert("Connexion annulée ou erreur.");
    }
  }

  async function refreshBalances(){
    const bal = await token.balanceOf(userAddress);
    const human = Number(ethers.formatUnits(bal, TOKEN_DECIMALS)).toLocaleString(undefined, { maximumFractionDigits: 6 });
    sdmBalEl.textContent = human + " SDM";

    // Vérifie allowance pour le staking (si tu fournis l'adresse)
    if (STAKING_ADDRESS.startsWith("0x") && STAKING_ADDRESS.length === 42){
      const allowance = await token.allowance(userAddress, STAKING_ADDRESS);
      const needed = amountIn.value ? ethers.parseUnits(amountIn.value || "0", TOKEN_DECIMALS) : 0n;
      stakeBtn.disabled = (allowance < needed) || needed === 0n; // activé uniquement si approve suffisant et montant > 0
    } else {
      stakeBtn.disabled = true; // pas d'adresse de staking encore
    }
    setStatus("");
  }

  async function addTokenToMetaMask(){
    if (!window.ethereum) return;
    try{
      await window.ethereum.request({
        method: "wallet_watchAsset",
        params: {
          type: "ERC20",
          options: {
            address: TOKEN_ADDRESS,
            symbol: TOKEN_SYMBOL,
            decimals: TOKEN_DECIMALS,
            image: location.origin + "/logo.png"
          }
        }
      });
    }catch(e){ /* ignore */ }
  }

  async function approve(){
    if (!token){ return alert("Connecte d’abord ton wallet."); }
    if (!STAKING_ADDRESS || STAKING_ADDRESS.length !== 42){ return alert("Adresse du contrat de staking manquante."); }

    const amount = amountIn.value.trim();
    if (!amount || Number(amount) <= 0) return alert("Entre un montant SDM à autoriser.");

    try{
      setStatus("Signature de la transaction Approve…");
      const amountWei = ethers.parseUnits(amount, TOKEN_DECIMALS);
      const tx = await token.approve(STAKING_ADDRESS, amountWei);
      await tx.wait();
      setStatus("Approve confirmé ✔");
      await refreshBalances();
    }catch(e){
      console.error(e);
      setStatus("Approve annulé/échoué.");
    }
  }

  // branchement événements
  connectBtn.addEventListener("click", connect);
  addTokenBtn.addEventListener("click", addTokenToMetaMask);
  approveBtn.addEventListener("click", approve);
  amountIn.addEventListener("input", ()=> { if (userAddress) refreshBalances(); });
</script>
